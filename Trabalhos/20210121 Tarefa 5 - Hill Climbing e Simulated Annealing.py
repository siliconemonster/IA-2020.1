# -*- coding: utf-8 -*-
"""Hill Climbing e Simulated Annealing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l_pyFwJ2_0nb2gM8cNj4jgyTCu396GvG

**<h1> HILL CLIMBING E SIMULATED ANNEALING**

## **Nesta tarefa você vai implementar os algoritmos Hill Climbing e Simulated Annealing e usá-los para resolver o problema das N-Rainhas. Os programas devem ser feitos preferencialmente na linguagem Python.**

--------------------------------------------------------------------------------

<h2>1 - Modelagem

<h3>a) Descreva como um tabuleiro N × N com N rainhas é representado no seu programa.
"""

import numpy as np
import random

x = 4
tabuleiroVazio = np.zeros((1, x), dtype=int)
print(tabuleiroVazio)

"""No caso de um tabuleiro 4x4, como o caso acima, temos um vetor de 1x4, vazio. Só pode haver uma rainha por coluna, então a coluna em que existir uma, será representada pelo número da linha.<br>
**Por exemplo:**<br>
Um tabuleiro do tipo: <br>
[0 &nbsp; 0 &nbsp; 0 &nbsp; 0]<br>
[R &nbsp; 0 &nbsp; 0 &nbsp; R]<br>
[0 &nbsp; R &nbsp; 0 &nbsp; 0]<br>
[0 &nbsp; 0 &nbsp; R &nbsp; 0]<br>
onde 0 representa onde está vazio, e R representa onde há uma rainha; na modelagem em questão, é representado por: <br>
[2 &nbsp; 3 &nbsp; 4 &nbsp; 2]

<h2> 2 - Implementação

<h3>a) Defina uma função que dado o tamanho do tabuleiro N, retorna um tabuleiro N ×N com N rainhas. O tabuleiro deve ser gerado de maneira aleatória.
"""

def geraTabuleiro(n):
  tabuleiro = np.zeros(( n), dtype=int)
  #print(tabuleiro)

  for x in range(n):
    posicaoRainha = random.randint(1, n)
    #print(posicaoRainha)
    tabuleiro[x] = posicaoRainha

  print("Tabuleiro Atual:")
  print(tabuleiro)
  return tabuleiro

geraTabuleiro(4)

"""<h3>b) Defina uma função que dado um tabuleiro qualquer, retorna todos os seus vizinhos."""

def geraVizinhos(n, tabuleiroAtual):
  quantViz = (n-1)*n # cada dama pode ocupar n-1 novas posições, e são n damas. Um vizinho é uma única dama mudar de posição
  vizinhos = np.zeros((quantViz, n), dtype=int)

  indice = 0
  for i in range(n):
    for j in range (1, n+1):
      if (tabuleiroAtual[i] != j):
        aux = []
        aux = tabuleiroAtual.copy()
        aux[i] = j
        vizinhos[indice] = aux
        indice = indice + 1

  print("Vizinhos:")
  print(vizinhos)
  return vizinhos

tabuleiro = geraTabuleiro(4)
geraVizinhos(4, tabuleiro)

"""<h3>c) Defina uma função que dado um tabuleiro qualquer, retorna um de seus vizinhos. A escolha do vizinho a ser retornado pela função deve ser aleatória."""

def vizinhoAleatorio(n, vizinhos):
  quantViz = (n-1)*n # cada dama pode ocupar n-1 novas posições, e são n damas. Um vizinho é uma única dama mudar de posição
  vizAleatorio = np.zeros(( n), dtype=int)

  posicao = random.randint(0, (quantViz-1))

  for x in range(n):
    vizAleatorio[x] = vizinhos[posicao][x]

  print("Vizinho aleatório:")
  print(vizAleatorio)
  return vizAleatorio

tabuleiro = geraTabuleiro(4)
vizinhos = geraVizinhos(4, tabuleiro)
vizinhoAleatorio(4, vizinhos)

"""<h3>d) Defina uma função que dado um tabuleiro qualquer, retorna a avaliação deste tabuleiro (número de ataques entre as rainhas)."""

def avaliaAtaques(n, tabuleiro):
  ataques = 0

  for i in range(n-1): # caso esteja na mesma coluna
    for j in range(i+1, n):
      if (tabuleiro[i] == tabuleiro[j]):
        ataques = ataques + 1

  for i in range(n-1): # caso esteja na mesma diagonal. Para baixo e para cima, respectivamente
    for j in range(i+1, n):
      if ((tabuleiro[i] == tabuleiro[j] + (j - i)) or (tabuleiro[i] == tabuleiro[j] - (j - i))):
        ataques = ataques + 1

  print("Número de ataques:")
  print(ataques)
  return ataques

tabuleiro = geraTabuleiro(4)
avaliaAtaques(4, tabuleiro)

"""<h2>3 - Hill Climbing

<h3>a) Implemente uma versão do algoritmo Hill Climbing, onde o tabuleiro sucessor do tabuleiro corrente será o primeiro vizinho dele (tabuleiro corrente) que tem uma avaliação melhor. Assim, se a avaliação do tabuleiro corrente Tc for igual a k, o primeiro tabuleiro vizinho de Tc encontrado com avaliação menor que k deve passar a ser o novo tabuleiro corrente.
"""

def hillClimbingPrimeiro (n, estadoInicial):
  corrente = estadoInicial
  
  while True:
    vizinhos = geraVizinhos(n, corrente)
    size = len(vizinhos)
    h = np.zeros(size, dtype=int)

    for i in range(size):
      aux = vizinhos[i]
      h[i] = avaliaAtaques(n, aux) # h[i] representa a heurística do vizinho[i]

    # hill climbing começa de fato aqui
    hCorr = avaliaAtaques(n, corrente) # heurística do nó corrente
    fCorr = -hCorr # função objetivo do nó corrente
    for i in range(size):
      if (i == 0):
        proximo = h[i]
        pos = 0
      elif (h[i] < proximo):
        proximo = h[i] # pega o primeiro menor ataque
        pos = i # pega a posição onde está o menor ataque
    vizinho = vizinhos[pos]
    hViz = h[pos] # heurística do nó vizinho
    fViz = -hViz # função objetivo do nó vizinho
    if (fViz <= fCorr):
      return corrente, hCorr
    corrente = vizinho # atualiza o novo estado atual
    print("Novo - Tabuleiro Atual:")
    print(corrente)

estadoInicial = geraTabuleiro(4)
hillClimbingPrimeiro(4, estadoInicial)

"""<h3>b) Implemente uma versão do algoritmo Hill Climbing, onde todos os tabuleiros vizinhos do tabuleiro corrente são avaliados e escolha para ser o novo tabuleiro corrente aquele que mais melhora a avaliação do tabuleiro corrente atual. No caso de haver mais de um tabuleiro, a escolha deve ser
feita de forma aleatória.
"""

def hillClimbingAleatorio (n, estadoInicial):
  corrente = estadoInicial
  
  while True:
    vizinhos = geraVizinhos(n, corrente)
    size = len(vizinhos)
    h = np.zeros(size, dtype=int)
    pos = np.zeros(size, dtype=int)

    for i in range(size): # preencher o vetor de posições com -1
      pos[i] = -1

    for i in range(size):
      aux = vizinhos[i]
      h[i] = avaliaAtaques(n, aux) # h[i] representa a heurística do vizinho[i]

    # hill climbing começa de fato aqui
    hCorr = avaliaAtaques(n, corrente) # heurística do nó corrente
    fCorr = -hCorr # função objetivo do nó corrente

    for i in range(size):
      if (i == 0):
        proximo = h[i]
      elif (h[i] < proximo):
        proximo = h[i] # descobre o menor ataque

    aux = 0
    for i in range(size): # no vetor de -1's, 
      if (h[i] == proximo): # os índices de onde os vizinhos de menor h 
        pos[aux] = i # são salvos nas primeiras posições de pos[]
        aux = aux + 1

    #print("-----------")
    #print("Vetor pos[] que guarda as posições de vizinhos de menor h[] (desconsiderar onde houver -1)")
    #print(pos)

    posicao = random.randint(0, (aux-1)) # escolho um valor aleatório entre as posições de pos que foram de fato alteradas
    #print("Posição aleatória do vetor acima:")
    #print(posicao)

    indice = pos[posicao] # esse índice recebe o exato valor aleatório mencionado anteriormente
    #print("Índice original escolhido aleatoriamente:")
    #print(indice)
    
    vizinho = vizinhos[indice] # Sugiro descomentar os 4 últimos prints para ajudar na visualização
    #print("Vizinho da posição do índice aleatório")
    #print(vizinho)
    hViz = h[indice] # heurística do nó vizinho
    fViz = -hViz # função objetivo do nó vizinho
    """print("fViz:")
    print(fViz)"""
    if (fViz <= fCorr):
      return corrente, hCorr
    corrente = vizinho # atualiza o novo estado atual
    #print("-----------")
    print("Novo - Tabuleiro Atual:")
    print(corrente)


estadoInicial = geraTabuleiro(4)
hillClimbingAleatorio(4, estadoInicial)

"""<h3>c) Analise o desempenho de cada umas das implementações. Considere:
 Tabuleiros de tamanho 4, 8, 16 e 32.
 Para cada tamanho de tabuleiro:<br>
&nbsp; &nbsp; &nbsp; &nbsp; – Indique quantas vezes você precisou executar os programas para encontrar uma solução.<br>
&nbsp; &nbsp; &nbsp; &nbsp; – Quantos tabuleiros correntes, em média, foram gerados em cada execução dos programas.

4x4 - Foram gerados em média:
*   Primeiro menor (3a): **Encontrou solução 40% das tentativas.**
* * 3 tabuleiros correntes quando encontrava a solução;
* * 2 tabuleiros correntes quando não encontrava. 
*   Aleatório (3b): **Encontrou solução 40% das tentativas.**
* * 3 tabuleiros correntes quando encontrava a solução;
* * 2 tabuleiros correntes quando não encontrava. 


8x8 - Foram gerados em média:
*   Primeiro menor (3a): **Encontrou solução 14% das tentativas.**
* * 6 tabuleiros correntes quando encontrava a solução;
* * 4 tabuleiros correntes quando não encontrava. 
*   Aleatório (3b): **Encontrou solução 13% das tentativas.**
* * 6 tabuleiros correntes quando encontrava a solução;
* * 4 tabuleiros correntes quando não encontrava. 

16x16 - Foram gerados em média:
*   Primeiro menor (3a): **Encontrou solução 6% das tentativas.**
* * 10 tabuleiros correntes quando encontrava a solução;
* * 8 tabuleiros correntes quando não encontrava. 
*   Aleatório (3b): ***Encontrou solução 5% das tentativas.***
* * 10 tabuleiros correntes quando encontrava a solução;
* * 7 tabuleiros correntes quando não encontrava solução.

32x32 - Foram gerados em média:
*   Primeiro menor (3a): **Encontrou solução 3% das tentativas.**
* * 21 tabuleiros correntes quando encontrava a solução;
* * 17 tabuleiros correntes quando não encontrava.  
*   Aleatório (3b): **Encontrou solução 2% das tentativas.**
* * 21 tabuleiros correntes quando encontrava a solução;
* * 15 tabuleiros correntes quando não encontrava.   <br>


<br>**É possível que esses valores se alterem um pouco, conforme outras tentativas sejam feitas, porém não significativamente.**

<h3>d) Quais conclusões você consegue tirar destes experimentos?

O algoritmo Hill Climbing é relativamente bom em casos onde o tabuleiro não é muito grande. Ele encontra a solução em aproximadamente metade das tentativas.<br>
As versões desse algoritmo onde se pega o primeiro vizinho de menor heurística e onde se pega um aleatório, dentre os de menor heurística, não fizeram muita diferença em relação a performances, com exceção no caso de 8x8, onde encontrou um pouco mais raramente ao usar o aleatório; e no caso de 16x16, onde o primeiro encontrou solução em alguns casos a menos que o aleatório.<br>
O algoritmo não é eficiente para tabuleiros de n grandes, mesmo que a quantidade de casos aumente conforme esse n aumenta. Disso surge a necessidade de um outro algoritmo, o Simulated Annealing, implementado na próxima seção.

<h2>4 - Simulated Annealing

<h3>a) Implemente o algoritmo Simulated Annealing. Os parâmetros de entrada do programa devem ser temperatura inicial TempInicial, o número máximo de iterações MaxIt e o fator de decaimento α.
"""

def simAnnealing(tempInicial, maxIt, alfa):
  n = 4 # tamanho do tabuleiro

  corrente = geraTabuleiro(n)
  melhorEstado = corrente
  tempCorrente = tempInicial

  for i in range(maxIt):
    vizinhos = geraVizinhos(n, corrente)
    vizinho = vizinhoAleatorio(n, vizinhos)
    hCorr = avaliaAtaques(n, corrente)
    fCorr = hCorr
    hMelhor = avaliaAtaques(n, melhorEstado)
    fMelhor = hMelhor
    hViz = avaliaAtaques(n, vizinho)
    fViz = hViz
    delta = fViz - fCorr
    if (delta <= 0):
      corrente = vizinho
      if (fViz <= fMelhor):
        melhorEstado = vizinho
      else:
        aleatorio = random.randint(0, 1)
        eulerPronto = np.exp((-delta)/tempCorrente)
        if (eulerPronto > aleatorio):
          corrente = vizinho

    tempCorrente = tempCorrente * alfa

  #print(melhorEstado, fMelhor)
  return (melhorEstado, fMelhor)
  #return (fMelhor) # Retorno automatizando a contagem

simAnnealing(100, 400, 0.5)

# Chamada automatizando a contagem:
#sucessos = 0
#for i in range(100): 
  #h = simAnnealing(10000, 100000, 0.1)
  #if (h == 0):
    #sucessos = sucessos + 1

#print(sucessos)

"""<h3>b) Determine experimentalmente valores para os parâmetros de entrada que permitam que uma solução
seja encontrada. Considere apenas tabuleiros de tamanho 4 e 8. Relate como a busca se comportou para os diferentes valores dos parâmetros de entrada que você usou.

##Condições onde obtive sucesso:<br>
* No tabuleiro de 4x4, fiz 10000 tentativas com temperatura de 100°, 400 iterações máximas, alfa = 0.5, e em todas elas, eu consegui obter o estado perfeito, onde nenhuma rainha se ataca.
* No tabuleiro de 8x8, fiz 100 tentativas com temperatura de 10000°, 100000 iterações máximas, alfa = 0.1, e em todas elas, eu consegui obter o estado perfeito, onde nenhuma rainha se ataca.<br>


## Outras tentativas:<br>
* Testei no tabuleiro de 4x4, 10000 tentativas com temperatura de 100°, 300 iterações máximas, alfa = 0.5, mas em 2 delas, eu não obtive sucesso.<br>
* Testei no tabuleiro de 8x8, 1000 tentativas com temperatura de 100°, 7000 iterações máximas, alfa = 0.5, mas em 25 delas, eu não obtive sucesso.<br>
* Testei no tabuleiro de 8x8, 100 tentativas com temperatura de 1000°, 90000 iterações máximas, alfa = 0.5, mas em 2 delas, eu não obtive sucesso.<br>
* Tentei manter a temperatura baixa nas iterações, e 100° me pareceu a melhor das opções.

<h3>c) Caso você tenha sido bem sucedido no item anterior (encontrou a solução do problema de 4 e 8 rainhas), use os mesmos parâmetros de entrada usados e execute o programa agora considerando tabuleiros de tamanho 16 e 32. O que acontece?

Usando os valores que usei no tabuleiro de 4x4:
* Para 16x16, obtive apenas 1 resultado perfeito em 50 tentativas (2% de êxito);
* Para 32x32, não obtive nenhum resultado perfeito em 50 tentativas (0% de êxito).<br><br>


Usando os valores que usei no tabuleiro de 8x8:
* Para 16x16, obtive 45 resultados perfeitos em 50 tentativas (90% de êxito)
* Para 32x32, obtive 19 resultados perfeitos em 50 tentativas (38% de êxito)

<h2>5 - Comparando os métodos Hill Climbing e Simulated Annealing na resolução do problema das N-rainhas, o que você pode concluir?

O Hill Climbing funciona melhor para casos onde o tabuleiro é menor, pois ele conta muito com a sorte de não se cair em um máximo local ou um plateau.<br>
Diferentemente, o Simulated annealing, ao atingir um mínimo local, troca de vizinho aleatoriamente. Ele é muito melhor em termos de performance: há casos onde sempre é possível encontrar um tabuleiro sem ataques, dependendo de seus parâmetros de entrada. É necessário descobrir experimentalmente quais são os melhores parâmetros.<br>
"""